Index: src/main/java/hoyocon/bomberman/Object/Player.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package hoyocon.bomberman.Object;\r\n\r\nimport com.almasb.fxgl.dsl.FXGL;\r\nimport com.almasb.fxgl.entity.Entity;\r\nimport hoyocon.bomberman.EntitiesState.EntityType;\r\nimport hoyocon.bomberman.EntitiesState.State;\r\nimport hoyocon.bomberman.Map.GMap;\r\nimport javafx.animation.PauseTransition;\r\nimport javafx.scene.image.Image;\r\nimport javafx.geometry.Bounds;\r\nimport javafx.scene.layout.Pane;\r\n\r\nimport com.almasb.fxgl.entity.component.Component;\r\nimport com.almasb.fxgl.texture.AnimatedTexture;\r\nimport com.almasb.fxgl.texture.AnimationChannel;\r\nimport javafx.util.Duration;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\npublic class Player extends Component {\r\n    // Vị trí người chơi\r\n    private int x, y;\r\n    \r\n    // Thuộc tính người chơi\r\n    private int lives;\r\n    private double speed;\r\n    private int bombCount;\r\n    private int maxBombs;\r\n    private boolean canPlaceBomb;\r\n    private final int FRAMESIZE = 45;\r\n    private final int NUMFRAME = 3;\r\n    \r\n    // Trạng thái người chơi\r\n    private State state;\r\n    private State lastAni;\r\n    \r\n    // Hình ảnh và animation\r\n    private AnimatedTexture texture;\r\n\r\n    private AnimationChannel walkup;\r\n    private AnimationChannel walkdown;\r\n    private AnimationChannel walkleft;\r\n    private AnimationChannel walkright;\r\n\r\n    private AnimationChannel idledown;\r\n\r\n    // Buff logic\r\n    private boolean unlimitedBomb = false;\r\n    private int flameRange = 1;\r\n    private double baseSpeed = 100;\r\n\r\n    // Map collision reference\r\n    private GMap gameGMap;\r\n    private static final double DEFAULT_COLLISION_SPEED = 10;\r\n\r\n    public Bounds getBounds() {\r\n        return entity.getViewComponent().getParent().getBoundsInParent();\r\n    }\r\n\r\n    // Buff timers\r\n    private Map<String, Long> activeBuffs = new HashMap<>();\r\n    private static final long BUFF_DURATION = 10 * 1000; // 10 seconds in milliseconds\r\n    \r\n    // Hitbox constants\r\n    private static final int PLAYER_WIDTH = 48;\r\n    private static final int PLAYER_HEIGHT = 48;\r\n    private static final int HITBOX_MARGIN = 2; // Margin to make hitbox slightly smaller than sprite\r\n    \r\n    // Get hitbox with margins for better collision detection\r\n    private double[][] getHitboxPoints(double x, double y) {\r\n        // Create points for each corner of hitbox with margin\r\n        return new double[][] {\r\n            // Top-left\r\n            {x + HITBOX_MARGIN, y + HITBOX_MARGIN},\r\n            // Top-right\r\n            {x + PLAYER_WIDTH - HITBOX_MARGIN, y + HITBOX_MARGIN},\r\n            // Bottom-left\r\n            {x + HITBOX_MARGIN, y + PLAYER_HEIGHT - HITBOX_MARGIN},\r\n            // Bottom-right\r\n            {x + PLAYER_WIDTH - HITBOX_MARGIN, y + PLAYER_HEIGHT - HITBOX_MARGIN},\r\n            // Middle top\r\n            {x + PLAYER_WIDTH / 2, y + HITBOX_MARGIN},\r\n            // Middle bottom\r\n            {x + PLAYER_WIDTH / 2, y + PLAYER_HEIGHT - HITBOX_MARGIN},\r\n            // Middle left\r\n            {x + HITBOX_MARGIN, y + PLAYER_HEIGHT / 2},\r\n            // Middle right\r\n            {x + PLAYER_WIDTH - HITBOX_MARGIN, y + PLAYER_HEIGHT / 2}\r\n        };\r\n    }\r\n    \r\n    // Enhanced collision detection\r\n    private boolean canMoveTo(double newX, double newY) {\r\n        if (gameGMap == null) return true;\r\n        \r\n        // Check all points of player hitbox\r\n        double[][] hitboxPoints = getHitboxPoints(newX, newY);\r\n        \r\n        for (double[] point : hitboxPoints) {\r\n            int col = GMap.pixelToTile(point[0]);\r\n            int row = GMap.pixelToTile(point[1]);\r\n            \r\n            // If any point collides with a non-walkable tile, movement is blocked\r\n            if (row < 0 || row >= gameGMap.height || col < 0 || col >= gameGMap.width || !gameGMap.isWalkable(row, col)) {\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        // If all points pass the check, movement is allowed\r\n        return true;\r\n    }\r\n\r\n    public Player() {\r\n        this.lives = 3;\r\n        this.speed = baseSpeed;\r\n        this.bombCount = 0;\r\n        this.maxBombs = 1;\r\n        this.canPlaceBomb = true;\r\n        this.state = State.IDLE;\r\n        this.lastAni = State.IDLE;\r\n        \r\n        Image upImage = new Image(getClass().getResourceAsStream(\"/assets/textures/player_up.png\"));\r\n        Image downImage = new Image(getClass().getResourceAsStream(\"/assets/textures/player_down.png\"));\r\n        Image leftImage = new Image(getClass().getResourceAsStream(\"/assets/textures/player_left.png\"));\r\n        Image rightImage = new Image(getClass().getResourceAsStream(\"/assets/textures/player_right.png\"));\r\n        Image idleImage = new Image(getClass().getResourceAsStream(\"/assets/textures/player_down.png\"));\r\n        \r\n        walkup = new AnimationChannel(upImage, NUMFRAME, FRAMESIZE, FRAMESIZE, Duration.seconds(0.5), 0, 2);\r\n        walkdown = new AnimationChannel(downImage, NUMFRAME, FRAMESIZE, FRAMESIZE, Duration.seconds(0.5), 0, 2);\r\n        walkleft = new AnimationChannel(leftImage, NUMFRAME, FRAMESIZE, FRAMESIZE, Duration.seconds(0.5), 0, 2);\r\n        walkright = new AnimationChannel(rightImage, NUMFRAME, FRAMESIZE, FRAMESIZE, Duration.seconds(0.5), 0, 2);\r\n        idledown = new AnimationChannel(idleImage, NUMFRAME, FRAMESIZE, FRAMESIZE, Duration.seconds(1), 0, 0);\r\n        \r\n        texture = new AnimatedTexture(idledown);\r\n    }\r\n    \r\n    public void setGameMap(GMap GMap) {\r\n        this.gameGMap = GMap;\r\n    }\r\n    \r\n    @Override\r\n    public void onAdded() {\r\n        entity.getViewComponent().addChild(texture);\r\n    }\r\n    \r\n    @Override\r\n    public void onUpdate(double tpf) {\r\n        updateAnimation();\r\n        updateBuffs();\r\n    }\r\n    \r\n    private void updateAnimation() {\r\n        switch (state) {\r\n            case UP:\r\n                texture.loopNoOverride(walkup);\r\n                break;\r\n            case RIGHT:\r\n                texture.loopNoOverride(walkright);\r\n                break;\r\n            case DOWN, IDLE:\r\n                texture.loopNoOverride(walkdown);\r\n                break;\r\n            case LEFT:\r\n                texture.loopNoOverride(walkleft);\r\n                break;\r\n        }\r\n    }\r\n    \r\n    private void updateBuffs() {\r\n        long currentTime = System.currentTimeMillis();\r\n        activeBuffs.entrySet().removeIf(entry -> {\r\n            boolean expired = currentTime - entry.getValue() > BUFF_DURATION;\r\n            if (expired) {\r\n                switch (entry.getKey()) {\r\n                    case \"unlimitedBomb\" -> unlimitedBomb = false;\r\n                    case \"speed\" -> speed = baseSpeed;\r\n                    // Nếu muốn reset flameRange về mặc định thì thêm ở đây\r\n                }\r\n            }\r\n            return expired;\r\n        });\r\n    }\r\n    \r\n\r\n\r\n    // Movement với collision detection\r\n    public boolean moveUp(double tpf) {\r\n        // Tính toán vị trí mới\r\n        double newX = entity.getX();\r\n        double newY = entity.getY() - speed * tpf;\r\n\r\n        // Kiểm tra va chạm tại vị trí mới\r\n        if (canMoveTo(newX, newY)) {\r\n            setState(State.UP);\r\n            entity.translateY(-speed * tpf);\r\n            return true;\r\n        } else {\r\n            setState(State.UP);\r\n            // Tìm khoảng cách gần nhất có thể di chuyển được\r\n            double safeDistance = findSafeDistance(entity.getX(), entity.getY(), 0, -1, speed * tpf);\r\n            if (safeDistance > 0) {\r\n                entity.translateY(-safeDistance);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean moveDown(double tpf) {\r\n        // Tính toán vị trí mới\r\n        double newX = entity.getX();\r\n        double newY = entity.getY() + speed * tpf;\r\n\r\n        // Kiểm tra va chạm tại vị trí mới\r\n        if (canMoveTo(newX, newY)) {\r\n            setState(State.DOWN);\r\n            entity.translateY(speed * tpf);\r\n            return true;\r\n        } else {\r\n            setState(State.DOWN);\r\n            // Tìm khoảng cách gần nhất có thể di chuyển được\r\n            double safeDistance = findSafeDistance(entity.getX(), entity.getY(), 0, 1, speed * tpf);\r\n            if (safeDistance > 0) {\r\n                entity.translateY(safeDistance);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean moveLeft(double tpf) {\r\n        // Tính toán vị trí mới\r\n        double newX = entity.getX() - speed * tpf;\r\n        double newY = entity.getY();\r\n\r\n        // Kiểm tra va chạm tại vị trí mới\r\n        if (canMoveTo(newX, newY)) {\r\n            setState(State.LEFT);\r\n            entity.translateX(-speed * tpf);\r\n            return true;\r\n        } else {\r\n            setState(State.LEFT);\r\n            // Tìm khoảng cách gần nhất có thể di chuyển được\r\n            double safeDistance = findSafeDistance(entity.getX(), entity.getY(), -1, 0, speed * tpf);\r\n            if (safeDistance > 0) {\r\n                entity.translateX(-safeDistance);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean moveRight(double tpf) {\r\n        // Tính toán vị trí mới\r\n        double newX = entity.getX() + speed * tpf;\r\n        double newY = entity.getY();\r\n\r\n        // Kiểm tra va chạm tại vị trí mới\r\n        if (canMoveTo(newX, newY)) {\r\n            setState(State.RIGHT);\r\n            entity.translateX(speed * tpf);\r\n            return true;\r\n        } else {\r\n            setState(State.RIGHT);\r\n            // Tìm khoảng cách gần nhất có thể di chuyển được\r\n            double safeDistance = findSafeDistance(entity.getX(), entity.getY(), 1, 0, speed * tpf);\r\n            if (safeDistance > 0) {\r\n                entity.translateX(safeDistance);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Phương thức tìm khoảng cách an toàn có thể di chuyển\r\n    private double findSafeDistance(double startX, double startY, int dirX, int dirY, double maxDistance) {\r\n        // Tìm khoảng cách an toàn lớn nhất có thể di chuyển\r\n        double safeDistance = 0;\r\n        double step = 1.0; // Bước nhỏ để tìm kiếm\r\n\r\n        for (double distance = step; distance <= maxDistance; distance += step) {\r\n            double newX = startX + dirX * distance;\r\n            double newY = startY + dirY * distance;\r\n\r\n            if (canMoveTo(newX, newY)) {\r\n                safeDistance = distance;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return safeDistance;\r\n    }\r\n    \r\n    public void stop() {\r\n        setState(State.IDLE);\r\n    }\r\n    \r\n    // Buff collision handling\r\n    public void checkBuffCollision(List<BuffEntity> buffEntities, Pane gamePane) {\r\n        List<BuffEntity> collectedBuffs = new ArrayList<>();\r\n\r\n        for (BuffEntity buffEntity : buffEntities) {\r\n            if (this.getBounds().intersects(buffEntity.getImageView().getBoundsInParent())) {\r\n                // Apply buff to player\r\n                buffEntity.getBuff().apply(this);\r\n\r\n                // Add to list of collected buffs\r\n                collectedBuffs.add(buffEntity);\r\n\r\n                // Remove buff image from gamePane\r\n                gamePane.getChildren().remove(buffEntity.getImageView());\r\n            }\r\n        }\r\n\r\n        // Remove collected buffs from buffEntities list\r\n        buffEntities.removeAll(collectedBuffs);\r\n    }\r\n\r\n    \r\n    // Đặt bom\r\n    public boolean placeBomb(Pane gamePane) {\r\n        if ((bombCount < maxBombs || unlimitedBomb) && canPlaceBomb) {\r\n            bombCount++;\r\n            canPlaceBomb = false;\r\n\r\n            double tileSize = GMap.TILE_SIZE;\r\n            double snappedX = Math.floor(getEntity().getX() / tileSize) * tileSize;\r\n            double snappedY = Math.floor(getEntity().getY() / tileSize) * tileSize;\r\n\r\n            // Tạo texture cho bom và thêm vào Pane\r\n            Bomb bombComponent = new Bomb(this);\r\n            AnimatedTexture bombTexture = bombComponent.getTexture();\r\n            Pane bombPane = new Pane();\r\n            bombPane.setPrefSize(tileSize, tileSize);\r\n            bombPane.getChildren().add(bombTexture);\r\n            bombPane.setLayoutX(snappedX);\r\n            bombPane.setLayoutY(snappedY);\r\n            gamePane.getChildren().add(bombPane);\r\n\r\n            // Bắt đầu hoạt ảnh\r\n            bombTexture.play();\r\n\r\n            // Hẹn giờ nổ sau 3 giây\r\n            PauseTransition delay = new PauseTransition(Duration.seconds(3));\r\n            delay.setOnFinished(evt -> {\r\n                // Xóa bom khỏi gamePane và thông báo nổ\r\n                gamePane.getChildren().remove(bombPane);\r\n                this.bombExploded();\r\n            });\r\n            delay.play();\r\n\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    // Xử lý khi bom nổ\r\n    public void bombExploded() {\r\n        if (bombCount > 0) {\r\n            bombCount--;\r\n        }\r\n        canPlaceBomb = true;\r\n    }\r\n    \r\n    // Xử lý khi bị thương\r\n    public boolean hit() {\r\n        lives--;\r\n        return lives <= 0;\r\n    }\r\n\r\n    // Buff logic\r\n    public void setUnlimitedBomb(boolean value) {\r\n        unlimitedBomb = value;\r\n        if (value) {\r\n            activeBuffs.put(\"unlimitedBomb\", System.currentTimeMillis());\r\n        }\r\n    }\r\n\r\n    public boolean isUnlimitedBomb() {\r\n        return unlimitedBomb;\r\n    }\r\n\r\n    public void increaseFlameRange(int delta) {\r\n        flameRange += delta;\r\n        if (flameRange < 1) flameRange = 1;\r\n        activeBuffs.put(\"flameRange\", System.currentTimeMillis());\r\n    }\r\n\r\n    public void increaseSpeed(int delta) {\r\n        speed = baseSpeed + delta * 50;\r\n        activeBuffs.put(\"speed\", System.currentTimeMillis());\r\n    }\r\n\r\n    // Logic khi nhặt vật phẩm\r\n    public void pickUpItem(String itemType) {\r\n        switch (itemType) {\r\n            case \"speed\":\r\n                increaseSpeed(1);\r\n                break;\r\n            case \"flameRange\":\r\n                increaseFlameRange(1);\r\n                break;\r\n            case \"unlimitedBomb\":\r\n                setUnlimitedBomb(true);\r\n                break;\r\n            default:\r\n                System.out.println(\"Unknown item type: \" + itemType);\r\n        }\r\n    }\r\n\r\n\r\n    // Getters và Setters\r\n    public State getState() {\r\n        return state;\r\n    }\r\n    \r\n    public void setState(State state) {\r\n        this.state = state;\r\n    }\r\n    \r\n    public double getSpeed() {\r\n        return speed;\r\n    }\r\n    \r\n    public void setSpeed(double speed) {\r\n        this.speed = speed;\r\n    }\r\n    \r\n    public int getLives() {\r\n        return lives;\r\n    }\r\n    \r\n    public void setLives(int lives) {\r\n        this.lives = lives;\r\n    }\r\n    \r\n    public int getMaxBombs() {\r\n        return maxBombs;\r\n    }\r\n    \r\n    public void setMaxBombs(int maxBombs) {\r\n        this.maxBombs = maxBombs;\r\n    }\r\n    \r\n    public boolean isCanPlaceBomb() {\r\n        return canPlaceBomb;\r\n    }\r\n    \r\n    public void setCanPlaceBomb(boolean canPlaceBomb) {\r\n        this.canPlaceBomb = canPlaceBomb;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/hoyocon/bomberman/Object/Player.java b/src/main/java/hoyocon/bomberman/Object/Player.java
--- a/src/main/java/hoyocon/bomberman/Object/Player.java	(revision 7580ceec446f20ccb4c702366670d3649196b42c)
+++ b/src/main/java/hoyocon/bomberman/Object/Player.java	(date 1745739669824)
@@ -342,12 +342,13 @@
             gamePane.getChildren().add(bombPane);
 
             // Bắt đầu hoạt ảnh
-            bombTexture.play();
+            bombTexture.loop();
 
             // Hẹn giờ nổ sau 3 giây
             PauseTransition delay = new PauseTransition(Duration.seconds(3));
             delay.setOnFinished(evt -> {
                 // Xóa bom khỏi gamePane và thông báo nổ
+                System.out.println("Bomb exploded!");
                 gamePane.getChildren().remove(bombPane);
                 this.bombExploded();
             });
